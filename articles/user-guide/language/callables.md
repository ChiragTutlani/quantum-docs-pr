---
title: Callables in Q#
description: How the callable types of Q#, operations and functions, are specified.
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 03/05/2020
ms.topic: article
uid: microsoft.quantum.guide.language.callables
---

# Callables in Q#

To do:
- 


## from 'file structure'
## Operation Declarations

Operations are the core of Q#, roughly analogous to functions in other languages.
Each Q# source file may define any number of operations.

Operation names must be unique within a namespace and may not conflict with type and function names.

An operation declarations consists of the keyword `operation`, followed by the symbol that is the operation’s name, a typed identifier tuple that defines the arguments to the operation, a colon `:`, a type annotation that describes the operation’s result type, optionally an annotation with the operation characteristics, an open brace `{`, the body of the operation declaration, and a final closing brace `}`.

The body of the operation declaration either consists of the default implementation or of a list of specializations.
The default implementation can be specified directly within the declaration if only the implementation of the default body specialization needs to specified explicitly.
In this case, an annotation with the operation characteristics in the declaration is useful to ensure that the compiler auto-generates other specializations based on the default implementation. 

For example 

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit 
is Adj + Ctl { // implies the existence of an adjoint, a controlled, and a controlled adjoint specialization
    H(here);
    CNOT(here, there);
}
```

Operation characteristics define what kinds of functors can be applied to the declared operation, and what effect they have. 
If an operation implements a unitary transformation, then it is possible to define how the operation acts when *adjointed* or *controlled*.
The existence of these specializations can be declared as part of the operation signature. The corresponding implementation for each such implicitly declared specialization is then generated by the compiler. 
In the example above, an adjoint, a controlled, and a controlled adjoint specialization are generated by the compiler. 

In the case where the implementation cannot be generated by the compiler, it can be explicitly specified. 
Such explicit specialization declarations can either consist of a suitable generation directive that clarify how a certain specialization is to be built, or a user defined implementation. 
The code in `PrepareEntangledPair` above for example is equivalent to the code below containing explicit specialization declarations: 

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit {
    body (...) { // default body specialization
        H(here);
        CNOT(here, there);
    }

    adjoint auto; // auto-generate adjoint specialization
    controlled auto; // auto-generate controlled specialization
    controlled adjoint auto; // auto-generate controlled adjoint specialization
}
```
The keyword `auto` indicates that the compiler should determine how to generate the specialization implementation.
If the compiler cannot generate the implementation for a certain specialization without further instructions - like a more precise generation directive -, or if a more efficient implementation can be given, then the implementation may also be manually defined.

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit
is Ctl + Adj {
    body (...) { // default body specialization
        H(here);
        CNOT(here, there);
    }

    controlled (cs, ...) { // user defined implementation for the controlled specialization
        Controlled H(cs, here);
        Controlled X(cs + [here], there);
    }

    adjoint invert; 
    controlled adjoint invert; 
}
```

In the example above, `adjoint invert;` indicates that the adjoint specialization is to be generated by inverting the body implementation, and `controlled adjoint invert;` indicates that the controlled adjoint specialization is to be generated by inverting the given implementation of the controlled specialization.

For an operation to support application of the `Adjoint` and/or `Controlled` functor, its return type necessarily needs to be `Unit`. 


### Explicit Specialization Declarations

Q# operations may contain the following explicit specialization declarations:

- The `body` specialization specifies the implementation of the operation with no functors applied.
- The `adjoint` specialization specifies the implementation of the operation with the `Adjoint` functor applied.
- The `controlled` specialization specifies the implementation of the operation with the `Controlled` functor applied.
- The `controlled adjoint` specialization specifies the implementation of the
  operation with both the `Adjoint` and `Controlled` functors applied.
  This specialization can also be named `adjoint controlled`, since the two functors commute.


An operation specialization consists of the specialization tag (e.g. `body`, or `adjoint`, etc.) followed by one of:

- An explicit declaration as described below.
- A directive that tells the compiler how to generate the specialization,
  one of:
  - `intrinsic`, which indicates that the specialization is provided by the target machine.
  - `distribute`, which may be used with the `controlled` and `controlled adjoint` specializations.
    When used with `controlled`, it indicates that the compiler should compute
    the specialization by applying `Controlled` to all of the operations in the `body`.
    When used with `controlled adjoint`, it indicates that the compiler
    should compute the specialization by applying `Controlled` to all of the
    operations in the `adjoint` specialization.
  - `invert`, which indicates that the compiler should compute the
    `adjoint` specialization by inverting the `body`, i.e. reversing the order of operations and
    applying the adjoint to each one.
    When used with `adjoint controlled`, this indicates that the compiler
    should compute the specialization by inverting the `controlled` specialization.
  - `self`, to indicate that the adjoint specialization is the
    the same as the `body` specialization.
    This is legal for the `adjoint` and `adjoint controlled` specializations.
    For `adjoint controlled`, `self` implies that the `adjoint controlled`
    specialization is the same as the `controlled` specialization.
  - `auto`, to indicate that the compiler should select an
    appropriate directive to apply.
    `auto` may not be used for the `body` specialization.

The directives and `auto` all require a closing semi-colon `;`.
The `auto` directive resolves to the following generation directive if an explicit declaration of the `body` is provided:

- The `adjoint` specialization is generated according to the directive `invert`.
- The `controlled` specialization is generated according to the directive `distribute`.
- The `adjoint controlled` specialization is generated according to the directive `invert` if an explicit
  declaration for `controlled` is given but not one for `adjoint`, and
  `distribute` otherwise.

> [!TIP]   
> If an operation is self-adjoint, explicitly specify either the adjoint or the controlled adjoint specialization via the generation directive `self` to allow the compiler to make use of that information for optimization purposes.

A specialization declaration containing a user defined implementation consists of an argument tuple followed by a statement block with the Q# code that implements the specialization.
In the argument list, `...` is used to represent the arguments declared for the operation as a whole.
For `body` and `adjoint`, the argument list should always be `(...)`; for `controlled` and `adjoint controlled`, the argument list should be a symbol that represents the array of control qubits, followed by `...`, enclosed in parentheses; for example, `(controls,...)`.

If one or more specializations besides the default body need to be explicitly declared, then the implementation for the default body needs to be wrapped into a suitable specialization declaration as well:

```qsharp
operation CountOnes(qubits: Qubit[]) : Int {

    body (...) // default body specialization
    {
        mutable n = 0;
        for (qubit in qubits) {
            set n += M(q) == One ? 1 | 0;
        }
        return n;
    }

    ...
```

### Adjoint

The adjoint of an operation specifies how the complex conjugate transpose of the operation is implemented, i.e. how the operation acts when "run in reverse".
It is legal to specify an operation with no adjoint; for instance, measurement operations have no adjoint because they are not invertible.
An operation supports the `Adjoint` functor if its declaration contains an implicit or explicit declaration of an adjoint specialization.
An explicitly declared controlled adjoint specialization implies the existence of an adjoint specialization. 

For operation whose body contains repeat-until-success loops, set statements, measurements, return statements, or calls to other operations that do not support the `Adjoint` functor, auto-generating an adjoint specialization following the `invert` or `auto` directive is not possible.

### Controlled

The controlled version of an operation specifies how a quantum-controlled version of the operation is implemented, i.e. how an operation acts when applied conditioned on the state of a quantum register.
A more complete description is provided in the [Controlled](xref:microsoft.quantum.language.type-model#controlled) section.

It is legal to specify an operation with no controlled version; for instance, measurement operations have no controlled version because they are not controllable.
An operation supports the `Controlled` functor if and only if its declaration contains an implicit or explicit declaration of a controlled specialization.
An explicitly declared controlled adjoint specialization implies the existence of a controlled specialization. 

For an operation whose body contains calls to other operations that does not support the `Controlled` functor, auto-generating a controlled specialization following the `distribute` or `auto` directive is not possible.

### Controlled Adjoint

The controlled adjoint version of an operation specifies how a quantum-controlled version of the adjoint of the operation is implemented.
It is legal to specify an operation with no controlled adjoint version; for instance, measurement operations have no controlled adjoint version because they are neither controllable nor invertible.

A controlled adjoint specialization for an operation needs to exist if and only if both an adjoint and a controlled specialization exist. In that case, the existence of the controlled adjoint specialization is inferred and an appropriate specialization is generated by the compiler if no implementation has been defined explicitly. 

For an operation whose body contains calls to other operations that do not have a controlled adjoint version, auto-generating an adjoint specialization following the `invert`, `distribute` or `auto` directive is not possible.


### Examples

An operation declaration might be as simple as the following, which defines the primitive Pauli X operation:

```qsharp
operation X (qubit : Qubit) : Unit
is Adj + Ctl {
    body intrinsic;
    adjoint self;
}
```

The following defines the teleport operation.

```qsharp
// Entangle two qubits.
// Assumes that both qubits are in the |0> state.
operation EPR (q1 : Qubit, q2 : Qubit) : Unit 
is Adj + Ctl {
    H(q2);
    CNOT(q2, q1);
}

// Teleport the quantum state of the source to the target.
// Assumes that the target is in the |0> state.
operation Teleport (source : Qubit, target : Qubit) : Unit {

    // Get a temporary for the Bell pair
    using (ancilla = Qubit())
    {
        // Create a Bell pair between the temporary and the target
        EPR(target, ancilla);

        // Do the teleportation
        Adjoint EPR (ancilla, source);

        if (MResetZ(source) == One) {
            X(target);
        }
        if (MResetZ(ancilla) == One) {
            Z(target);
        }
    }
}
```

## Function Declarations

Functions are purely classical routines in Q#.
Each Q# source file may define any number of functions.

A function declaration consists of the keyword `function`, followed by the symbol that is the function’s name, a typed identifier tuple, a type annotation that describes the function's return type, and a statement block that describes the implementation of the function.

The statement block defining a function must be enclosed in
`{` and `}` like any other statement block.

Function names must be unique within a namespace and may not conflict with operation and type names.
Functions may not allocate or borrow qubits, or call operations. 
Partial application of operations or passing around operation typed values is fine.

For example,

```qsharp
function DotProduct(a : Double[], b : Double[]) : Double {
    if (Length(a) != Length(b)) {
        fail "Arrays are not compatible";
    }

    mutable accum = 0.0;
    for (i in 0..Length(a)-1) {
        set accum += a[i] * b[i];
    }
    return accum;
}
```



## from 'Statements'
## Conjugations

In contrast to classical bits, releasing quantum memory is slightly more involved since blindly resetting qubits can have undesired effects on the remaining computation if the qubits are still entangled. 
This can be avoided by properly "undoing" performed computations prior to releasing the memory. 
A common pattern in quantum computing is hence the following: 

```qsharp
operation ApplyWith<'T>(
    outerOperation : ('T => Unit is Adj), 
    innerOperation : ('T => Unit), 
    target : 'T) 
: Unit {

    outerOperation(target);
    innerOperation(target);
    Adjoint outerOperation(target);
}
```

:new: Starting with our 0.9 release, we support a conjugation statement that implements the transformation above. Using that statement, the operation `ApplyWith` can be implemented in the following way:

```qsharp
operation ApplyWith<'T>(
    outerOperation : ('T => Unit is Adj), 
    innerOperation : ('T => Unit), 
    target : 'T) 
: Unit {

    within{ 
        outerOperation(target);
    }
    apply {
        innerOperation(target);
    }
}
```
Such a conjugation statement obviously becomes far more useful if the outer and inner transformation are not readily available as operations but are instead more convenient to describe by a block consisting of several statements. 

The inverse transformation for the statements defined in the within-block is automatically generated by the compiler and executed after the apply-block completes.
Since any mutable variables used as part of the within-block cannot be rebound in the apply-block, the generated transformation is guaranteed to be the adjoint of the computation in the within-block. 

## Expression Evaluation Statements

Any call expression of type `Unit` may be used as a statement.
This is primarily of use when calling operations on qubits that return `Unit` because the purpose of the statement is to modify the implicit quantum state.
Expression evaluation statements require a terminating semicolon.

For example,

```qsharp
X(q);
CNOT(control, target);
Adjoint T(q);
```


## From "Expressions"
## Callable Expressions

A callable literal is the name of an operation or function defined in the compilation scope.
For instance, `X` is an operation literal that refers to the standard library `X` operation, and `Message` is a function literal that refers to the standard library `Message` function.

If an operation supports the `Adjoint` functor, then `Adjoint op` is an operation expression.
Similarly, if the operation supports the `Controlled` functor, then `Controlled op` is an operation expression.
The types of these expressions are specified in [Functors](xref:microsoft.quantum.language.type-model#functors).

Functors (`Adjoint` and `Controlled`) bind more closely than all other operators, except for the unwrap operator `!` and array indexing with []`.
Thus, the following are all legal, assuming that the operations support the functors used:

```qsharp
Adjoint Op(qs)
Controlled Op(controls, targets)
Controlled Adjoint Op(controls, targets)
Adjoint WrappedOp!(qs)
```

A callable literal may be used as a value, say to assign to a variable or to pass to another callable.
In this case, if the callable has type parameters, they must be provided as part of the callable value.
A callable value cannot have any unspecified type parameters.

For instance, if `Fun` is a function with signature `'T1->Unit`:

```qsharp
let f = Fun<Int>;            // f is Int->Unit.
SomeOtherFun(Fun<Double>);   // A Double->Unit is passed to SomOtherFun.
let g = Fun;                 // This causes a compilation error.
SomeOtherFun(Fun);           // This also causes a compilation error.
```

## Callable Invocation Expressions

Given a callable (operation or function) expression and a tuple expression of the input type of the callable's signature, an invocation expression may be formed by appending the tuple expression to the callable expression.
The type of the invocation expression is the output type of the callable's signature.

For example, if `Op` is an operation with signature `((Int, Qubit) => Double)`, `Op(3, qubit1)` is an expression of type `Double`.
Similarly, if `Sin` is a function with signature `(Double -> Double)`, `Sin(0.1)` is an expression of type `Double`.
Finally, if `Builder` is a function with signature `(Int -> (Int -> Int))`, then `Builder(3)` is a function from Into to Int.

Invoking the result of a callable-valued expression requires an extra pair of parentheses around the callable expression.
Thus, to invoke the result of calling `Builder` from the previous paragraph, the correct syntax is:

```qsharp
(Builder(3))(2)
```

When invoking a type-parameterized callable, the actual type parameters may be specified within angle brackets `<` and `>` after the callable expression.
This is usually unnecessary as the Q# compiler will infer the actual types.
It is required for partial application (see below) if a type-parameterized argument is left unspecified.
It is also sometimes useful when passing operations with different functor supports to a callable.

For instance, if `Func` has signature `('T1, 'T2, 'T1) -> 'T2`, `Op1` and `Op2` have signature `(Qubit[] => Unit is Adj)`, and `Op3` has signature `(Qubit[] => Unit)`, to invoke `Func` with `Op1` as the first argument, `Op2` as the second, and `Op3` as the third:

```qsharp
let combinedOp = Func<(Qubit[] => Unit), (Qubit[] => Unit is Adj)>(Op1, Op2, Op3);
```

The type specification is required because `Op3` and `Op1` have different types, so the compiler will treat this as ambiguous without the specification.

### Partial Application

Given a callable expression, a new callable may be created by providing a subset of the arguments to the callable.
This is called _partial application_.

In Q#, a partially applied callable is expressed by writing a normal invocation expression, but using an underscore, `_`, for the unspecified arguments.
The resulting callable has the same result type as the base callable, and the same specializations for operations.
The input type of the partial application is simply the original type with the specified arguments removed.

If a mutable variable is passed as a specified argument when creating a partial application, the current value of the variable is used.
Changing the value of the variable afterward will not impact the partial application.

For example, if `Op` has type `((Int, ((Qubit, Qubit), Double)) => Unit is Adj)`:

- `Op(5,(_,_))` has type `(((Qubit,Qubit), Double) => Unit is Adj)`, and so has `Op(5,_)`.
- `Op(_,(_,1.0))` has type `((Int, (Qubit,Qubit)) => Unit is Adj)`.
- `Op(_,((q1,q2),_))` has type `((Int,Double) => Unit is Adj)`.
   Note that we have applied singleton tuple equivalence here.

If the partially-applied callable has type parameters that cannot be inferred by the compiler, they must be provided at the invocation site.
The partial application cannot have any unspecified type parameters.

For example, if `Op` has type `(('T1, Qubit, 'T1) => Unit : Adjoint)`:

```qsharp
let f1 = Op<Int>(_, qb, _); // f1 has type ((Int,Int) => Unit is Adj)
let f2 = Op(5, qb, _);      // f2 has type (Int => Unit is Adj)
let f3 = Op(_,qb, _);       // f3 generates a compilation error
```

### Recursion

Q# callables are allowed to be directly or indirectly recursive.
That is, an operation or function may call itself, or it may call another callable that directly or indirectly calls the callable operation.

There are two important comments about the use of recursion, however:

- The use of recursion in operations is likely to interfere with certain optimizations.
  This may have a substantial impact on the execution time of the algorithm.
- When executing on an actual quantum device, stack space may be limited, and so deep recursion may lead to a runtime error.
  In particular, the Q# compiler and runtime do not identify and optimize tail recursion.


## From "Types"

### Type-Parameterized Functions and Operations

Callable types may contain type parameters.
Type parameters are indicated by a symbol prefixed by a single quote; for example, `'A` is a legal type parameter.

A type parameter may appear more than once in a single signature.
For example, a function that applies another function to each element of an array and returns the collected results would have signature `(('A[], 'A->'A) -> 'A[])`.
Similarly, a function that returns the composition of two operations might have signature `((('A=>'B), ('B=>'C)) -> ('A=>'C))`.

When invoking a type-parameterized callable, all arguments that have the same type parameter must be of the same type.

Q# does not provide a mechanism for constraining the possible types that might be substituted for a type parameter.

### Type Compatibility

An operation with additional functors supported may be used anywhere an operation with fewer functors but the same signature is expected.
For instance, an operation of type `(Qubit => Unit is Adj)` may be used anywhere an operation of type `(Qubit => Unit)` is expected.

Q# is *covariant* with respect to callable return types: a callable that returns a type `'A` is compatible with a callable with the same input type and a result type that `'A` is compatible with.

Q# is *contravariant* with respect to input types: a callable that takes a type `'A` as input is compatible with a callable with the same result type and an input type that is compatible with `'A`.

That is, given the following definitions:

```qsharp
operation Invert(qubits : Qubit[]) : Unit 
is Adj {...} 

operation ApplyUnitary(qubits : Qubit[]) : Unit 
is Adj + Ctl {...} 

function ConjugateInvertWith(
    inner : (Qubit[] => Unit is Adj),
    outer : (Qubit[] => Unit is Adj))
: (Qubit[] => Unit is Adj) {...}

function ConjugateUnitaryWith(
    inner : (Qubit[] => Unit is Adj + Ctl),
    outer : (Qubit[] => Unit is Adj))
: (Qubit[] => Unit is Adj + Ctl) {...}
```

the following are true:

- The function `ConjugateInvertWith` may be invoked with an `inner` argument of either `Invert` or `ApplyUnitary`.
- The function `ConjugateUnitaryWith` may be invoked with an `inner` argument of `ApplyUnitary`, but not `Invert`.
- A value of type `(Qubit[] => Unit is Adj + Ctl)` may be returned from `ConjugateInvertWith`.

> [!IMPORTANT]
> Q# 0.3 introduces a significant difference in the behavior of user-defined types.

User-defined types are treated as a wrapped version of the underlying type, rather than as a subtype.
This means that a value of a user-defined type is not usable where a value of the underlying type is expected.

### Functors

A functor in Q# is a factory that defines a new operation from another operation.
Functors have access to the implementation of the base operation when defining the implementation of the new operation.
Thus, functors can perform more complex functions than traditional higher-level functions.

Functors do not have a representation in the Q# type system. 
It is thus currently not possible to bind them to a variable or pass them as arguments. 

A functor is used by applying it to an operation, returning a new operation.
For example, the operation that results from applying the `Adjoint` functor to the `Y` operation is written as `Adjoint Y`.
The new operation may then be invoked like any other operation.
Thus, `Adjoint Y(q1)` applies the Adjoint functor to the `Y` operation to generate a new operation, and applies that new operation to `q1`.

Similarly, `Controlled X(controls, target)` applies the Controlled functor to the `X` operation to generate a new operation, and applies that new operation to `controls` and `target`.

The two standard functors in Q# are `Adjoint` and `Controlled`.

#### Adjoint

In quantum computing, the adjoint of an operation is the complex conjugate transpose of the operation.
For operations that implement a unitary operator, the adjoint is the inverse of the operation.
For a simple operation that just invokes a sequence of other unitary operations on a set of qubits, the adjoint may be computed by applying the adjoints of the sub-operations on the same qubits, in the reverse sequence.

Given an operation expression, a new operation expression may be formed using the `Adjoint` functor.
For instance, `Adjoint QFT` designates the adjoint of the `QFT` operation.
The new operation has the same signature and type as the base operation.
In particular, the new operation also allows `Adjoint`, and will allow `Controlled` if and only if the base operation did.

The Adjoint functor is its own inverse; that is, `Adjoint Adjoint Op` is always the same as `Op`.

#### Controlled

The controlled version of an operation is a new operation that effectively applies the base operation only if all of the control qubits are in a specified state.
If the control qubits are in superposition, then the base operation is applied coherently to the appropriate part of the superposition.
Thus, controlled operations are often used to generate entanglement.

In Q#, controlled versions always take an array of control qubits, and the specified state is always for all of the control qubits to be in the computational (`PauliZ`) `One` state, $\ket{1}$.
Controlling based on other states may be achieved by applying the appropriate unitary operation to the control qubits before the controlled operation, and then applying the inverses of the unitary operation after the controlled operation.
For example, applying an `X` operation to a control qubit before and after a controlled operation will cause the operation to control on the `Zero` state ($\ket{0}$) for that qubit; applying an `H` operation before and after will control on the `PauliX` `One` state, that is -1 eigenvalue of Pauli X, $\ket{-} \mathrel{:=} (\ket{0} - \ket{1}) / \sqrt{2}$ rather than the `PauliZ` `One` state.

Given an operation expression, a new operation expression may be formed using the `Controlled` functor.
The signature of the new operation is based on the signature of the original operation.
The result type is the same, but the input type is a two-tuple with a qubit array that holds the control qubit(s) as the first element and the arguments of the original operation as the second element.
The new operation supports `Controlled`, and will support `Adjoint` if and only if the original operation did.

If the original operation took only a single argument, then singleton tuple equivalence will come into play here.
For instance, `Controlled X` is the controlled version of the `X` operation. 
`X` has type `(Qubit => Unit is Adj + Ctl)`, so `Controlled X` has type `((Qubit[], (Qubit)) => Unit is Adj + Ctl)`; because of singleton tuple equivalence, this is the same as `((Qubit[], Qubit) => Unit is Adj + Ctl)`.

If the base operation took several arguments, remember to enclose the corresponding arguments of the controlled version of the operation in parentheses to convert them into a tuple.
For instance, `Controlled Rz` is the controlled version of the `Rz` operation. 
`Rz` has type `((Double, Qubit) => Unit is Adj + Ctl)`, so `Controlled Rz` has type
`((Qubit[], (Double, Qubit)) => Unit is Adj + Ctl)`.
Thus, `Controlled Rz(controls, (0.1, target))` would be a valid invocation of `Controlled Rz` (note the parentheses around `0.1, target`).

As another example, `CNOT(control, target)` can be implemented as `Controlled X([control], target)`. 
If a target should be controlled by 2 control qubits (CCNOT), we can use `Controlled X([control1, control2], target)` statement.


