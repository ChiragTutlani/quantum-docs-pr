---
title: Callables in Q#
description: How the callable types of Q#, operations and functions, are specified.
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 03/05/2020
ms.topic: article
uid: microsoft.quantum.guide.language.callables
---

# Callables in Q#

To do:
- 


For an operation to support application of the `Adjoint` and/or `Controlled` functor, its return type necessarily needs to be `Unit`. 

## Q# Operations and Functions

Q# programs consist of one or more *operations* that describe side effects quantum operations can have on quantum data, and one or more *functions* that allow modifications to classical data. 
In contrast to operations, functions are used to describe purely classical behavior and do not have any effects besides computing classical output values.

Each operation defined in Q# may then call any number of other operations, including the built-in intrinsic operations defined by the language. 
The particular way in which these intrinsic operations are defined depends on the target machine.
When compiled, each operation is represented as a .NET class type that can be provided to target machines.

## Defining New Operations

As described above, the most basic building block of a quantum program written in Q# is an *operation*, which can either be called from classical .NET applications, e.g., using a simulator, or by other operations within Q#.
Each operation takes an input, produces an output, and specifies the implementation for one or more operation specializations.
For instance, the following operation defines only a default body specialization and takes a single qubit as its input, then calls the built-in `X` operation on that input:

```qsharp
operation BitFlip(target : Qubit) : Unit {
    X(target);
}
```

The keyword `operation` begins the operation definition, and is followed by the name; here, `BitFlip`.
Next, the type of the input is defined as `Qubit`, along with a name `target` for referring to the input within the new operation.
Similarly, the `Unit` defines that the operation's output is empty.
This is used similarly to `void` in C# and other imperative languages, and is equivalent to `unit` in F# and other functional languages.

> [!NOTE]
> We will explore this in more detail below, but each operation in Q# takes exactly one input and returns exactly one output.
> Multiple inputs and outputs are then represented using *tuples*, which collect multiple values together into a single value.
> Informally, we say that Q# is a "tuple-in tuple-out" language.
> Following this concept, `()` should then be read as the "empty" tuple, which has the type `Unit`.

Within the new operation, the implementation can be specified directly within the declaration if only the implementation of the default body specialization needs to be specified explicitly. Additionally, it is possible to define the implementations of, for example, one or more `functor` operations, as elaborated below. In the example above, the only statement is to call the built-in Q# operation <xref:microsoft.quantum.intrinsic.x>.

Operations can also return more interesting types than `Unit`.
For instance, the <xref:microsoft.quantum.intrinsic.m> operation returns an output of type `Result`, representing having performed a measurement. We can either pass the output from an operation to another operation, or can use it with the `let` keyword to define a new variable.
<!-- Link to UID for superdense conceptual and example documentation. -->
This allows for representing classical computation that interacts with quantum operations at a low level, such as in superdense coding:

```qsharp
operation Superdense(here : Qubit, there : Qubit) : (Result, Result) {

    CNOT(there, here);
    H(there);

    let firstBit = M(there);
    let secondBit = M(here);

    return (firstBit, secondBit);
}
```
### Functors: adjoint and controlled operations

If an operation implements a unitary transformation, then it is possible to define how the operation acts when *adjointed* or *controlled*. 
An adjoint specialization of an operation specifies how it acts when run in reverse, while a controlled specialization specifies how an operation acts when applied conditioned on the state of a quantum register.

The existence of these specializations can be declared as part of the operation signature: `is Adj + Ctl` in the following example. 
The corresponding implementation for each such implicitly declared specialization is then generated by the compiler. 

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit
is Adj + Ctl { // implies the existence of an adjoint, a controlled, and a controlled adjoint specialization
    H(here);
    CNOT(here, there);
}
```

> [!NOTE]
> Many operations in Q# represent unitary gates.
> If $U$ is the unitary gate represented by an operation `U`, then `Adjoint U` represents the unitary gate $U^\dagger$, which is the complex conjugate transpose.

To call a specialization of an operation, use the `Adjoint` or `Controlled` keywords.
For example, the superdense coding example above can be written more compactly by using the adjoint of `PrepareEntangledPair` to transform the entangled state back into an unentangled pair of qubits:

```qsharp
operation Superdense(here : Qubit, there : Qubit) : (Result, Result) {
    Adjoint PrepareEntangledPair(there, here);

    let firstBit = M(there);
    let secondBit = M(here);

    return (firstBit, secondBit);
}
```

There are a number of important limitations to consider when designing operations for use with functors.
Most critically, specializations for an operation that uses the output value of any other operation cannot be auto-generated by the compiler, as it is ambiguous how to reorder the statements in such an operation to obtain the same effect.

Functors do not have a representation in the Q# type system. 
It is thus currently not possible to bind them to a variable or pass them as arguments. 

## (MORE) Functors: adjoint and controlled operations
NEED TO BRING THIS TOGETHER WITH THE ABOVE SECTION, OR CREATE A NEW PAGE FOR 'ADVANCED STUFF'

A functor in Q# is a factory that defines a new operation from another operation.
Functors have access to the implementation of the base operation when defining the implementation of the new operation.
Thus, functors can perform more complex functions than traditional higher-level functions. 
The two standard functors in Q# are `Adjoint` and `Controlled`.

A functor is used by applying it to an operation, returning a new operation.
For example, the operation that results from applying the `Adjoint` functor to the `Y` operation is written as `Adjoint Y`.
The new operation may then be invoked like any other operation.
Thus, `Adjoint Y(q1)` applies the Adjoint functor to the `Y` operation to generate a new operation, and applies that new operation to `q1`.

Similarly, `Controlled X(controls, target)` applies the Controlled functor to the `X` operation to generate a new operation, and applies that new operation to `controls` and `target`.

### Adjoint

In quantum computing, the adjoint of an operation specifies how the complex conjugate transpose of the operation is implemented; i.e. the "inverse" of the operation, such that successively applying an operation and then its adjoint to a state leaves the state unchanged. 
In the matrix representation of such an operation, this means that the operation and its adjoint multiply to the identity matrix.
For a simple operation that just invokes a sequence of other unitary operations on a set of qubits, the adjoint may be computed by applying the adjoints of the sub-operations on the same qubits, in the reverse order.

Given an operation expression, a new operation expression may be formed using the `Adjoint` functor.
For instance, `Adjoint QFT` designates the adjoint of the `QFT` operation.
The new operation has the same signature and type as the base operation.
In particular, the new operation also allows `Adjoint`, and will allow `Controlled` if and only if the base operation did.

The Adjoint functor is its own inverse; that is, `Adjoint Adjoint Op` is always the same as `Op`.


### Controlled

The controlled version of an operation is a new operation that effectively applies the base operation only if all of the control qubits are in a specified state.
If the control qubits are in superposition, then the base operation is applied coherently to the appropriate part of the superposition.
Thus, controlled operations are often used to generate entanglement.

In Q#, controlled versions always take an array of control qubits, and the specified state is always for all of the control qubits to be in the computational (`PauliZ`) `One` state, $\ket{1}$.
Controlling based on other states may be achieved by applying the appropriate unitary operation to the control qubits before the controlled operation, and then applying the inverses of the unitary operation after the controlled operation.
For example, applying an `X` operation to a control qubit before and after a controlled operation will cause the operation to control on the `Zero` state ($\ket{0}$) for that qubit; applying an `H` operation before and after will control on the `PauliX` `One` state, that is -1 eigenvalue of Pauli X, $\ket{-} \mathrel{:=} (\ket{0} - \ket{1}) / \sqrt{2}$ rather than the `PauliZ` `One` state.

Given an operation expression, a new operation expression may be formed using the `Controlled` functor.
The signature of the new operation is based on the signature of the original operation.
The result type is the same, but the input type is a two-tuple with a qubit array that holds the control qubit(s) as the first element and the arguments of the original operation as the second element.
The new operation supports `Controlled`, and will support `Adjoint` if and only if the original operation did.

If the original operation took only a single argument, then singleton tuple equivalence will come into play here.
For instance, `Controlled X` is the controlled version of the `X` operation. 
`X` has type `(Qubit => Unit is Adj + Ctl)`, so `Controlled X` has type `((Qubit[], (Qubit)) => Unit is Adj + Ctl)`; because of singleton tuple equivalence, this is the same as `((Qubit[], Qubit) => Unit is Adj + Ctl)`.

If the base operation took several arguments, remember to enclose the corresponding arguments of the controlled version of the operation in parentheses to convert them into a tuple.
For instance, `Controlled Rz` is the controlled version of the `Rz` operation. 
`Rz` has type `((Double, Qubit) => Unit is Adj + Ctl)`, so `Controlled Rz` has type
`((Qubit[], (Double, Qubit)) => Unit is Adj + Ctl)`.
Thus, `Controlled Rz(controls, (0.1, target))` would be a valid invocation of `Controlled Rz` (note the parentheses around `0.1, target`).

As another example, `CNOT(control, target)` can be implemented as `Controlled X([control], target)`. 
If a target should be controlled by 2 control qubits (CCNOT), we can use `Controlled X([control1, control2], target)` statement.

### Type Compatibility

An operation with additional functors supported may be used anywhere an operation with fewer functors but the same signature is expected.
For instance, an operation of type `(Qubit => Unit is Adj)` may be used anywhere an operation of type `(Qubit => Unit)` is expected.

Q# is *covariant* with respect to callable return types: a callable that returns a type `'A` is compatible with a callable with the same input type and a result type that `'A` is compatible with.

Q# is *contravariant* with respect to input types: a callable that takes a type `'A` as input is compatible with a callable with the same result type and an input type that is compatible with `'A`.

That is, given the following definitions:

```qsharp
operation Invert(qubits : Qubit[]) : Unit 
is Adj {...} 

operation ApplyUnitary(qubits : Qubit[]) : Unit 
is Adj + Ctl {...} 

function ConjugateInvertWith(
    inner : (Qubit[] => Unit is Adj),
    outer : (Qubit[] => Unit is Adj))
: (Qubit[] => Unit is Adj) {...}

function ConjugateUnitaryWith(
    inner : (Qubit[] => Unit is Adj + Ctl),
    outer : (Qubit[] => Unit is Adj))
: (Qubit[] => Unit is Adj + Ctl) {...}
```

the following are true:

- The function `ConjugateInvertWith` may be invoked with an `inner` argument of either `Invert` or `ApplyUnitary`.
- The function `ConjugateUnitaryWith` may be invoked with an `inner` argument of `ApplyUnitary`, but not `Invert`.
- A value of type `(Qubit[] => Unit is Adj + Ctl)` may be returned from `ConjugateInvertWith`.

> [!IMPORTANT]
> Q# 0.3 introduces a significant difference in the behavior of user-defined types.

User-defined types are treated as a wrapped version of the underlying type, rather than as a subtype.
This means that a value of a user-defined type is not usable where a value of the underlying type is expected.


## Defining New Functions

Q# also allows for defining *functions*, which are distinct from operations in that they are not allowed to have any effects beyond calculating an output value.
In particular, functions cannot call operations, act on qubits, sample random numbers, or otherwise depend on state beyond the input value to a function.
As a consequence, Q# functions are *pure*, in that they always map the same input values to the same output values.
This allows the Q# compiler to safely reorder how and when functions are called when generating operation specializations.

Defining a function works similarly to defining an operation, except that no adjoint or controlled specializations can be defined for a function.
For instance:

```qsharp
function Square(x : Double) : (Double) {
    return x * x;
}
```
Whenever it is possible to do so, it is helpful to write out classical logic in terms of functions rather than operations, so that it can be more readily used from within operations.
If we had written `Square` as an operation, for example, then the compiler would not have been able to guarantee that calling it with the same input would consistently produce the same outputs.

To underscore the difference between functions and operations, consider the problem of classically sampling a random number from within a Q# operation:

```qsharp
operation U(target : Qubit) : Unit {

    let angle = RandomReal()
    Rz(angle, target)
}
```

Each time that `U` is called, it will have a different action on `target`.
In particular, the compiler cannot guarantee that if we added an `adjoint auto` specialization declaration to `U`, then `U(target); Adjoint U(target);` acts as identity (that is, as a no-op).
This violates the definition of the adjoint that we saw in [Vectors and Matrices](xref:microsoft.quantum.concepts.vectors), such that allowing to auto-generate an adjoint specialization in an operation where we have called the operation <xref:microsoft.quantum.math.randomreal> would break the guarantees provided by the compiler; <xref:microsoft.quantum.math.randomreal> is an operation for which no adjoint or controlled version exists.

On the other hand, allowing function calls such as `Square` is safe, in that the compiler can be assured that it only needs to preserve the input to `Square` in order to keep its output stable.
Thus, isolating as much classical logic as possible into functions makes it easy to reuse that logic in other functions and operations alike.

## from 'Statements'
## Conjugations

In contrast to classical bits, releasing quantum memory is slightly more involved since blindly resetting qubits can have undesired effects on the remaining computation if the qubits are still entangled. 
This can be avoided by properly "undoing" performed computations prior to releasing the memory. 
A common pattern in quantum computing is hence the following: 

```qsharp
operation ApplyWith<'T>(
    outerOperation : ('T => Unit is Adj), 
    innerOperation : ('T => Unit), 
    target : 'T) 
: Unit {

    outerOperation(target);
    innerOperation(target);
    Adjoint outerOperation(target);
}
```

:new: Starting with our 0.9 release, we support a conjugation statement that implements the transformation above. Using that statement, the operation `ApplyWith` can be implemented in the following way:

```qsharp
operation ApplyWith<'T>(
    outerOperation : ('T => Unit is Adj), 
    innerOperation : ('T => Unit), 
    target : 'T) 
: Unit {

    within{ 
        outerOperation(target);
    }
    apply {
        innerOperation(target);
    }
}
```
Such a conjugation statement obviously becomes far more useful if the outer and inner transformation are not readily available as operations but are instead more convenient to describe by a block consisting of several statements. 

The inverse transformation for the statements defined in the within-block is automatically generated by the compiler and executed after the apply-block completes.
Since any mutable variables used as part of the within-block cannot be rebound in the apply-block, the generated transformation is guaranteed to be the adjoint of the computation in the within-block. 



## From "Expressions"


### Recursion

Q# callables are allowed to be directly or indirectly recursive.
That is, an operation or function may call itself, or it may call another callable that directly or indirectly calls the callable operation.

There are two important comments about the use of recursion, however:

- The use of recursion in operations is likely to interfere with certain optimizations.
  This may have a substantial impact on the execution time of the algorithm.
- When executing on an actual quantum device, stack space may be limited, and so deep recursion may lead to a runtime error.
  In particular, the Q# compiler and runtime do not identify and optimize tail recursion.


## From "Types"






