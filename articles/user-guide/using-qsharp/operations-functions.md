---
title: Basics of defining operations and functions
description: The fundamentals of defining operations and functions
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 03/05/2020
ms.topic: article
uid: microsoft.quantum.guide.using.opsfns
---

# Basics of defining operations and functions

## from operations and functions in qdevtechs
## Q# Operations and Functions

Q# programs consist of one or more *operations* that describe side effects quantum operations can have on quantum data, and one or more *functions* that allow modifications to classical data. In contrast to operations, functions are used to describe purely classical behavior and do not have any effects besides computing classical output values.

Each operation defined in Q# may then call any number of other operations, including the built-in intrinsic operations defined by the language. The particular way in which these intrinsic operations are defined depends on the target machine. When compiled, each operation is represented as a .NET class type that can be provided to target machines.

## Defining New Operations

As described above, the most basic building block of a quantum program written in Q# is an *operation*, which can either be called from classical .NET applications, e.g., using a simulator, or by other operations within Q#.
Each operation takes an input, produces an output, and specifies the implementation for one or more operation specializations.
For instance, the following operation defines only a default body specialization and takes a single qubit as its input, then calls the built-in `X` operation on that input:

```qsharp
operation BitFlip(target : Qubit) : Unit {
    X(target);
}
```

The keyword `operation` begins the operation definition, and is followed by the name; here, `BitFlip`.
Next, the type of the input is defined as `Qubit`, along with a name `target` for referring to the input within the new operation.
Similarly, the `Unit` defines that the operation's output is empty.
This is used similarly to `void` in C# and other imperative languages, and is equivalent to `unit` in F# and other functional languages.

> [!NOTE]
> We will explore this in more detail below, but each operation in Q# takes exactly one input and returns exactly one output.
> Multiple inputs and outputs are then represented using *tuples*, which collect multiple values together into a single value.
> Informally, we say that Q# is a "tuple-in tuple-out" language.
> Following this concept, `()` should then be read as the "empty" tuple, which has the type `Unit`.

Within the new operation, the implementation can be specified directly within the declaration if only the implementation of the default body specialization needs to be specified explicitly. Additionally, it is possible to define the implementations of, for example, one or more `functor` operations, as elaborated below. In the example above, the only statement is to call the built-in Q# operation <xref:microsoft.quantum.intrinsic.x>.

Operations can also return more interesting types than `Unit`.
For instance, the <xref:microsoft.quantum.intrinsic.m> operation returns an output of type `Result`, representing having performed a measurement. We can either pass the output from an operation to another operation, or can use it with the `let` keyword to define a new variable.
<!-- Link to UID for superdense conceptual and example documentation. -->
This allows for representing classical computation that interacts with quantum operations at a low level, such as in superdense coding:

```qsharp
operation Superdense(here : Qubit, there : Qubit) : (Result, Result) {

    CNOT(there, here);
    H(there);

    let firstBit = M(there);
    let secondBit = M(here);

    return (firstBit, secondBit);
}
```
### Functors, adjoint and controlled
If an operation implements a unitary transformation, then it is possible to define how the operation acts when *adjointed* or *controlled*. An adjoint specialization of an operation specifies how it acts when run in reverse, while a controlled specialization specifies how an operation acts when applied conditioned on the state of a quantum register.
The existence of these specializations can be declared as part of the operation signature: `is Adj + Ctl` in the following example. The corresponding implementation for each such implicitly declared specialization is then generated by the compiler. 

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit
is Adj + Ctl { // implies the existence of an adjoint, a controlled, and a controlled adjoint specialization
    H(here);
    CNOT(here, there);
}
```

> [!NOTE]
> Many operations in Q# represent unitary gates.
> If $U$ is the unitary gate represented by an operation `U`, then `Adjoint U` represents the unitary gate $U^\dagger$.

In the case where the implementation cannot be generated by the compiler, it can be explicitly specified. 
Such explicit specialization declarations can consist of a suitable generation directive or a user defined implementation. The code in `PrepareEntangledPair` above for example is equivalent to the code below containing explicit specialization declarations: 

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit {
    body (...) { // default body specialization
        H(here);
        CNOT(here, there);
    }

    adjoint auto; // auto-generate adjoint specialization
    controlled auto; // auto-generate controlled specialization
    controlled adjoint auto; // auto-generate controlled adjoint specialization
}
```
The keyword `auto` indicates that the compiler should determine how to generate the specialization implementation.
If the compiler cannot generate the implementation for a certain specialization automatically, or if a more efficient implementation can be given, then the implementation may also be manually defined.

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit
is Ctl + Adj {
    body (...) { // default body specialization
        H(here);
        CNOT(here, there);
    }

    controlled (cs, ...) { // user defined implementation for the controlled specialization
        Controlled H(cs, here);
        Controlled X(cs + [here], there);
    }

    adjoint invert; 
    controlled adjoint invert; 
}
```
In the example above, `adjoint invert;` indicates that the adjoint specialization is to be generated by inverting the body implementation, and `controlled adjoint invert;` indicates that the controlled adjoint specialization is to be generated by inverting the given implementation of the controlled specialization.

We will see more examples of this in [Higher-Order Control Flow](xref:microsoft.quantum.concepts.control-flow).

To call a specialization of an operation, use the `Adjoint` or `Controlled` keywords.
For example, the superdense coding example above can be written more compactly by using the adjoint of `PrepareEntangledPair` to transform the entangled state back into an unentangled pair of qubits:

```qsharp
operation Superdense(here : Qubit, there : Qubit) : (Result, Result) {
    Adjoint PrepareEntangledPair(there, here);

    let firstBit = M(there);
    let secondBit = M(here);

    return (firstBit, secondBit);
}
```

There are a number of important limitations to consider when designing operations for use with functors.
Most critically, specializations for an operation that uses the output value of any other operation cannot be auto-generated by the compiler, as it is ambiguous how to reorder the statements in such an operation to obtain the same effect.


## Defining New Functions

Q# also allows for defining *functions*, which are distinct from operations in that they are not allowed to have any effects beyond calculating an output value.
In particular, functions cannot call operations, act on qubits, sample random numbers, or otherwise depend on state beyond the input value to a function.
As a consequence, Q# functions are *pure*, in that they always map the same input values to the same output values.
This allows the Q# compiler to safely reorder how and when functions are called when generating operation specializations.

Defining a function works similarly to defining an operation, except that no adjoint or controlled specializations can be defined for a function.
For instance:

```qsharp
function Square(x : Double) : (Double) {
    return x * x;
}
```
Whenever it is possible to do so, it is helpful to write out classical logic in terms of functions rather than operations, so that it can be more readily used from within operations.
If we had written `Square` as an operation, for example, then the compiler would not have been able to guarantee that calling it with the same input would consistently produce the same outputs.

To underscore the difference between functions and operations, consider the problem of classically sampling a random number from within a Q# operation:

```qsharp
operation U(target : Qubit) : Unit {

    let angle = RandomReal()
    Rz(angle, target)
}
```

Each time that `U` is called, it will have a different action on `target`.
In particular, the compiler cannot guarantee that if we added an `adjoint auto` specialization declaration to `U`, then `U(target); Adjoint U(target);` acts as identity (that is, as a no-op).
This violates the definition of the adjoint that we saw in [Vectors and Matrices](xref:microsoft.quantum.concepts.vectors), such that allowing to auto-generate an adjoint specialization in an operation where we have called the operation <xref:microsoft.quantum.math.randomreal> would break the guarantees provided by the compiler; <xref:microsoft.quantum.math.randomreal> is an operation for which no adjoint or controlled version exists.

On the other hand, allowing function calls such as `Square` is safe, in that the compiler can be assured that it only needs to preserve the input to `Square` in order to keep its output stable.
Thus, isolating as much classical logic as possible into functions makes it easy to reuse that logic in other functions and operations alike.
